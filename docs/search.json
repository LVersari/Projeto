[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bem-vindos!",
    "section": "",
    "text": "Nessa página web se encontra o projeto desenvolvido pelos alunos: Gabriel Antônio Dalapicula Serafini e Lucas Rodrigues Versari, na Disciplina de Pós-graduação do Departamento de Fitopatologia da Universidade Federal de Viçosa [UFV], FIP606 - Análises e Visualização de Dados em Fitopatologia, ministrada pelo Professor Dr. Emerson Medeiros Del Ponte.\nQualquer dúvida ou sugestão, no menu superior ao lado direito se encontram endereços de e-mail e redes sociais dos criadores dessa página.\n\n\n Back to top"
  },
  {
    "objectID": "Introducao.html",
    "href": "Introducao.html",
    "title": "Projeto",
    "section": "",
    "text": "Sensibilidade in vitro de isolados de Corynespora cassiicola a fungicidas, oriundos de áreas com o cultivo de soja-algodão em sucessão.\nA baixa eficácia do controle químico na redução do progresso da doença Mancha Alvo (Corynespora cassiicola) em cultivos de soja e algodão, tem sido observada em diferentes regiões produtoras do Brasil. A eficiência reduzida dos fungicidas pode ser atribuída a redução ou perda de sensibilidade da população patogênica. Principalmente em regiões com o cultivo de plantas hospedeiras de C. cassiicola, como soja-algodão.\nO objetivo desse trabalho foi determinar a sensibilidade de isolados de C. cassiicola à fungicidas, obtidos a partir de amostras foliares de plantas de soja e algodão, por meio da técnica de inibição do crescimento micelial in vitro.\nDeterminou-se a sensibilidade de nove isolados de C. cassiicola, oriundos de diferentes regiões produtoras com o cultivo de soja-algodão em sucessão.\n\n\n\n\n\n\nOs tratamentos utilizados foram: Fungicidas Fox, Orkestra e Mancozeb, nas concentrações 0,5 mg L-1 ; 1,0 mg L-1 ; 2,5 mg L-1 ; 5,0 mg L-1 ; 10 mg L-1 ; 20 mg L-1 ; 50 mg L-1 e a testemunha sem fungicida.\nO delineamento experimental empregado foi o inteiramente casualizado (DIC), com três repetições. De cada isolado foram transferidos discos de 5 mm de diâmetro para placas de Petri com meio BDA + tratamentos e incubados a 28°C. As medições do diâmetro médio da colônia fúngica foram realizadas durante quinze dias, com intervalo de dois a três dias entre cada avaliação. Os dados foram submetidos a análises de regressão não-linear, utilizando os modelos Weibull 1, Weibull 2, LL.3 e LN.3 para identificar o modelo que melhor representa a relação Log doses de cada fungicida e crescimento micelial de cada isolado, para determinar a CE50 (concentração efetiva de fungicida capaz de reduzir 50% do crescimento micelial). A sensibilidade dos isolados foi classificada com base no valor da EC50 , para os fungicidas: Fox e Orkestra, Alta sensibilidade (&lt; 1 mg L-1), moderada sensibilidade (1 - 10 mg L-1) , pouca sensibilidade (10,1 - 50 mg L-1) e insensibilidade (&gt; 50 mg L-1), e para o fungicida Mancozeb: sensibilidade (&lt; 50 mg L-1) e insensibilidade (&gt; 50 &gt; 50 mg L-1).\nOs isolados apresentaram comportamentos distintos de sensibilidade entre si, para os fungicidas Fox e Orkestra, variando a sensibilidade entre alta sensibilidade e insensibilidade. Todos isolados foram sensíveis ao fungicidas Mancozeb. Não houve relação entre a origem e sensibilidade dos isolados ao fungicidas testados.\n\n\n Back to top"
  },
  {
    "objectID": "paginicial.html",
    "href": "paginicial.html",
    "title": "Projeto",
    "section": "",
    "text": "options(\"install.lock\"=FALSE)\nlibrary(conflicted)\nconflict_prefer(\"filter\", \"dplyr\")\nconflict_prefer(\"lag\", \"dplyr\")\n\n1. Pacotes utilizados para criar o mapa da página Sobre\n\nlibrary(rnaturalearthhires)\n\nlibrary(rnaturalearth)\n\nlibrary(tidyverse)\n\nlibrary(sf)\n\nlibrary(ggiraph)\n\nlibrary(dplyr)\nlibrary(stats)\nlibrary(conflicted)\n\n2. Carregando o Dataset\nPara a leitura e importação de dados em Excel, utilizaremos o pacote `readxl`, para isso é necessário que instale e carregue este pacote. O pacote `readxl`, permite a leitura de arquivos Excel (.xlsx) sendo especialmente útil para importar dados que são frequentemente armazenados em planilhas.\n\nlibrary(readxl)\ndados &lt;- read_excel(\"SensibilidadeCory2020.xlsx\")\nhead(dados)\n\n# A tibble: 6 × 7\n  trat   aval isolado  dias   rep  dose  diam\n  &lt;chr&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Fox₢      1       1     2     1     0  23.5\n2 Fox₢      1       1     2     2     0  21.4\n3 Fox₢      1       1     2     3     0  20.0\n4 Fox₢      1       2     2     1     0  25.6\n5 Fox₢      1       2     2     2     0  26.4\n6 Fox₢      1       2     2     3     0  26.3\n\n\n3. Visualização de dados\nPara a visualização do conjunto de dados primeiramente foi calculadas as médias de diâmetro médio da colônia de cada isolado, em cada fungicida, dose e avaliação.\nUtilizou a função ggplot() do pacote tidyverse e diferentes formatos gráficos. A variável resposta crescimento micelial (mm) foi visualizada por fungicida, em cada nível dos fatores: Isolados, Avaliações e Doses.\nGráfico de pontos: Esse tipo de gráfico é interessante para visualização da dispersão dos dados, onde cada ponto representa uma observação. Foi utilizado esse tipo de gráfico no trabalho devido o número de repetições (3) ser relativamente pequeno, facilitando a visualização. Utilizou a função geom_point() para plotar o gráfico.\nGráfico de linhas: Utilizou a função geom_line() do pacote ggplot2 para criar um gráfico de linhas. Esse tipo de gráfico é usado para visualizar tendências ou padrões ao longo de uma variável contínua, como, tempo, temperatura, doses.\nO gráfico de linhas aqui foi utilizado para ligar os pontos, mostrando o comportamento do crescimento micelial (mm) em em relação as variáveis contínuas: doses e avaliações no tempo.\nfacet_wrap(): foi usado para criar uma grade gráfica, onde cada subgráfico representa um subconjunto dos dados.\nPara melhor visualização das variáveis respostas, utilizamos a “Dose” como um fator e adicionamos facetas com a função facet_wrap() para vizualizarmos os tratamentos separadamente.\n3.1 Crescimento micelial x Doses (Isolados)\n\nlibrary(ggsci)\nconflicts_prefer(dplyr::filter)\n# Médias\nmedias &lt;- dados |&gt; \n  group_by(trat,dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam, na.rm = TRUE), .groups = 'drop') |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = dose, y = media_diam, color = factor(isolado), group = isolado)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~aval)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Concentração\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Isolados\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\n3.2 Crescimento micelial x Doses (Avaliações)\n\n# Médias\nconflicts_prefer(dplyr::filter)\nmedias &lt;- dados |&gt; \n  group_by(trat, dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam, na.rm = TRUE), .groups = 'drop') |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = dose, y = media_diam, color = factor(aval), group = aval)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~isolado)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Concentração\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Avaliação\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\n3.3 Crescimento micelial x Avaliações (Doses)\n\nconflicts_prefer(dplyr::filter)\nmedias &lt;- dados |&gt; \n  group_by(trat, dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam, na.rm = TRUE), .groups = 'drop') |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = aval, y = media_diam, color = factor(dose), group = dose)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~isolado)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Avaliações\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Dose\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\n4. Hipóteses\nHipótese nula (H0): Não há diferença de sensibilidade entre os isolados para nenhum dos fungicidas.\nHipótese alternativa (H1): Há pelo menos uma diferença de sensibilidade entre os isolados para um dos fungicidas.\n5. Modelos de Regressão Não-Linear\nOs dados foram submetidos a análises de regressão não-linear, utilizando os modelos Weibull 1, Weibull 2, LL.3 e LN.3 para identificar o modelo que melhor representa a relação Log doses de cada fungicida e crescimento micelial de cada isolado, para estimar a CE50 (concentração efetiva de fungicida capaz de reduzir 50% do crescimento micelial).\n\nlibrary(dplyr)\nlibrary(drc)\nlibrary(ggplot2)\n\n# Função para ajustar múltiplos modelos de dose-resposta e selecionar o melhor modelo\najustar_e_selecionar_melhor_modelo &lt;- function(dados, tratamento, isolado, avaliacao) {\n  data_filtrado &lt;- dados %&gt;%\n    filter(trat == tratamento, isolado == isolado, aval == avaliacao) %&gt;%\n    group_by(dose) %&gt;%\n    slice_head(n = 3) %&gt;%\n    ungroup()\n  \n  # Ajustar os modelos\n  modelo1 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = LN.3()), error = function(e) NULL)\n  modelo2 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = LL.3()), error = function(e) NULL)\n  modelo3 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = W1.3()), error = function(e) NULL)\n  modelo4 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = W2.3()), error = function(e) NULL)\n  \n  # Selecionar o melhor modelo com base no AIC\n  modelos &lt;- list(LN.3 = modelo1, LL.3 = modelo2, W1.3 = modelo3, W2.3 = modelo4)\n  modelos_validos &lt;- modelos[!sapply(modelos, is.null)]\n  \n  if (length(modelos_validos) &gt; 0) {\n    aic_values &lt;- sapply(modelos_validos, AIC, simplify = TRUE)\n    melhor_modelo &lt;- names(aic_values)[which.min(aic_values)]\n    return(list(modelo = modelos_validos[[melhor_modelo]], tipo = melhor_modelo, AIC = aic_values[melhor_modelo]))\n  } else {\n    return(NULL)\n  }\n}\n\n# Lista para armazenar os melhores modelos\nmelhores_modelos &lt;- list()\n\n# Lista de tratamentos, isolados e avaliações únicos\ntratamentos &lt;- unique(dados$trat)\nisolados &lt;- unique(dados$isolado)\navaliacoes &lt;- unique(dados$aval)\n\n# Iterar sobre todas as combinações de tratamento, isolado e avaliação\nfor (tratamento in tratamentos) {\n  for (isolado in isolados) {\n    for (avaliacao in avaliacoes) {\n      # Ajustar e selecionar o melhor modelo para a combinação atual\n      melhor_modelo &lt;- ajustar_e_selecionar_melhor_modelo(dados, tratamento, isolado, avaliacao)\n      chave &lt;- paste(tratamento, isolado, avaliacao, sep = \"-\")\n      melhores_modelos[[chave]] &lt;- melhor_modelo\n    }\n  }\n}\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\n# Função para plotar os dados e o melhor modelo\nplotar_melhor_modelo &lt;- function(dados, melhor_modelo, tratamento, isolado, avaliacao) {\n  data_filtrado &lt;- dados %&gt;%\n    filter(trat == tratamento, isolado == isolado, aval == avaliacao) %&gt;%\n    group_by(dose) %&gt;%\n    slice_head(n = 3) %&gt;%\n    ungroup()\n  \n  if (!is.null(melhor_modelo$modelo)) {\n    ggplot(data_filtrado, aes(x = dose, y = diam)) +\n      geom_point() +\n      geom_line(aes(y = predict(melhor_modelo$modelo)), color = 'blue') +\n      labs(title = paste(\"Tratamento:\", tratamento, \"Isolado:\", isolado, \"Avaliação:\", avaliacao),\n           subtitle = paste(\"Melhor modelo:\", melhor_modelo$tipo, \"AIC:\", round(melhor_modelo$AIC, 2)),\n           x = \"Dose\",\n           y = \"Diâmetro\") +\n      theme_minimal()\n  } else {\n    ggplot(data_filtrado, aes(x = dose, y = diam)) +\n      geom_point() +\n      labs(title = paste(\"Tratamento:\", tratamento, \"Isolado:\", isolado, \"Avaliação:\", avaliacao),\n           subtitle = \"Nenhum modelo ajustado\",\n           x = \"Dose\",\n           y = \"Diâmetro\") +\n      theme_minimal()\n  }\n}\n\n# Plotar os gráficos para cada combinação\nfor (chave in names(melhores_modelos)) {\n  comb &lt;- unlist(strsplit(chave, \"-\"))\n  tratamento &lt;- comb[1]\n  isolado &lt;- as.numeric(comb[2])\n  avaliacao &lt;- as.numeric(comb[3])\n  melhor_modelo &lt;- melhores_modelos[[chave]]\n  \n  print(plotar_melhor_modelo(dados, melhor_modelo, tratamento, isolado, avaliacao))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6. Estimativa da EC50\nUtilizou o pacote ec50estimator para estimar a EC50 de cada fungicida para cada isolado, nas seis avaliações.\n\nlibrary(ec50estimator)\ndf_ec50_LN &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::LN.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor inicial em vmmin não é finito\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\n\ndf_ec50_LL &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::LL.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor não finito fornecido por optim\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\n\ndf_ec50_W1 &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::W1.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor inicial em vmmin não é finito\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\ndf_ec50_W2 &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::W2.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor não finito fornecido por optim\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\nhead(df_ec50_LL)\n\n  ID trat aval    Estimate Std..Error      Lower     Upper\n1  1 Fox₢    1  93.4421515  28.332137  34.522247 152.36206\n2  2 Fox₢    1   0.4936527   4.651691  -9.180068  10.16737\n3  3 Fox₢    1  72.3221270  10.466677  50.555481  94.08877\n4  4 Fox₢    1 160.2615254  37.834200  81.580999 238.94205\n5  5 Fox₢    1   2.8077983  27.435216 -54.246856  59.86245\n6  6 Fox₢    1  11.5289497   7.078668  -3.191946  26.24985\n\nlibrary(DT)\ndatatable(df_ec50_W1 ,\n          extensions = 'Buttons',\n          options = list(\n            dom = 'Bfrtip',\n            buttons = c('copy', 'excel')))\n\n\n\n\n\ndatatable(df_ec50_W2 ,\n          extensions = 'Buttons',\n          options = list(\n            dom = 'Bfrtip',\n            buttons = c('copy', 'excel')))\n\n\n\n\n\n\n\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Função para criar o gráfico de EC50\nplot_ec50 &lt;- function(df_ec50, model_name) {\n  # Filtrar valores não positivos e maiores que 100\n  df_ec50 &lt;- df_ec50 %&gt;% filter(Estimate &gt; 0 & Estimate &lt; 100)\n  \n  # Visualização dos EC50s\n  p &lt;- as.data.frame(df_ec50) %&gt;% \n    mutate(ID = as.numeric(ID)) %&gt;% \n    ggplot(aes(ID, Estimate, color = trat)) +\n    geom_point(size = 2) +\n    geom_errorbar(aes(ymin = Lower, ymax = Upper, color = trat), width = 0) +\n    facet_wrap(~aval, scales = \"free_x\", ncol = 2) +\n    scale_y_log10() +\n    scale_x_continuous(breaks = 1:9) +\n    scale_color_manual(values = c(\"darkred\", \"steelblue\", \"darkgreen\")) +\n    labs(x = \"Isolados\", y = \"EC50\", title = paste(\"Modelo:\", model_name)) +\n    theme_minimal() +\n    coord_flip() +\n    theme(axis.text.y = element_text(angle = 90, vjust = 0.5, hjust = 1), legend.position = \"bottom\")\n  \n  return(p)\n}\n\n# Criar gráficos para cada modelo\nplot_LN &lt;- plot_ec50(df_ec50_LN, \"LN.3\")\nplot_LL &lt;- plot_ec50(df_ec50_LL, \"LL.3\")\nplot_W1 &lt;- plot_ec50(df_ec50_W1, \"W1.3\")\nplot_W2 &lt;- plot_ec50(df_ec50_W2, \"W2.3\")\n\n# Exibir os gráficos\nprint(plot_LN)\n\n\n\nprint(plot_LL)\n\n\n\nprint(plot_W1)\n\n\n\nprint(plot_W2)\n\n\n\n\n7. Classificação da sensibilidade milecial\nCom base nos critérios de informação Akaiake (AIC), foram selecionados para cada fungicida, isolado e avaliação, o melhor modelo matemático que representasse a relação inibição do crescimento micelial (%) x Log doses fungicida (mg L-1), para estimar a EC50 (Concentração efetiva de fungicida capaz de inibir 50% do crescimento micelial).\nCom base nos valores de EC50 foi classificada a sensibilidade dos isolados para cada fungicida e avaliação.\nPara os fungicidas Fox e Orkestra utilizou a classificação proposta por Edgington et al (1971).\nEC50 &lt; 1 mg L-1 (alta sensibilidade) ;\nEC50 entre 1 mg L-1 e 10 mg L-1 (moderada sensibilidade) ;\nEC50 entre 10,1 mg L-1 e 50 mg L-1 (pouca sensibilidade);\nEC50 &gt; 50 mg L-1 (insensibilidade).\nPara o fungicida Mancozeb a sensibilidade foi classificada em:\nSensibilidade (EC50 &lt; 50 mg L-1);\nInsensibilidade (EC50 &gt; 50 mg L-1).\n\n\n# A tibble: 1 × 7\n  format width height colorspace matte filesize density\n  &lt;chr&gt;  &lt;int&gt;  &lt;int&gt; &lt;chr&gt;      &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;  \n1 PNG     1272    424 sRGB       FALSE    23072 38x38  \n\n\n\n\n\n8. Interpretação\nCom base na EC50 e na classificação de sensibilidade dos isolados de Corynespora cassiicola aos fungicidas Fox, Orkestra e Mancozeb, rejeita a hipótese nula H0.\nHouve diferença de sensibilidade entre os isolados testados.\nPara o Fungicida Fox apenas o isolado 6 apresentou alta sensibilidade em todas as avaliações. Os isolados 1, 2, 3, 4 e 5 foram insensíveis ao fungicida Fox em todas as avaliações. Enquanto que os isolados 7, 8 e 9 apresentaram mudança de sensibilidade ao longo das avaliações.\nFungicida Orkestra: os isolados 1 e 3 foram altamente sensíveis em todas avaliações, o isolado 4 pouco sensível e o isolado 5 moderadamente sensível. Os isolados 2, 6, 7, 8 e 9 tiveram mudanças de sensibilidade ao longo das avaliações, sendo o isolado nas ultimas avaliações insensível, os isolados 6 e 8 pouco sensíveis e os isolados 7 e 9 moderadamente sensíveis.\nFungicida Mancozeb: Todos isolados foram sensíveis ao produto.\nNão houve uma relação entre origem dos isolados e padrão de sensibilidade aos fungicidas testados.\n\n\n\n Back to top"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 1.html",
    "href": "Projeto/FIP606_2024/Aula 1.html",
    "title": "Característica Principal",
    "section": "",
    "text": "R é uma linguagem de programação e um ambiente de software voltado para a análise estatística, visualização de dados e ciência de dados. Desenvolvido inicialmente por Ross Ihaka e Robert Gentleman na Universidade de Auckland, Nova Zelândia, R é amplamente utilizado em estatísticas, pesquisa científica, economia, bioinformática e outras áreas que requerem análise de dados.\n\nCaracterística Principal\nLinguagem de Programação: R é uma linguagem de programação interpretada, semelhante ao S, com uma sintaxe fácil de aprender e usar.\n\nAnálise Estatística: R fornece uma ampla variedade de técnicas estatísticas, incluindo modelagem linear e não linear, testes estatísticos, séries temporais, classificação e agrupamento.\nVisualização de Dados: R possui excelentes capacidades de visualização de dados, permitindo a criação de gráficos de alta qualidade para análise exploratória e apresentação de resultados.\nPacotes Extensíveis: O poder do R é ampliado por milhares de pacotes disponíveis no CRAN (Comprehensive R Archive Network), Bioconductor, e outros repositórios. Estes pacotes cobrem uma vasta gama de métodos e técnicas.\nComunidade Ativa: R tem uma grande e ativa comunidade de usuários e desenvolvedores que contribuem com pacotes, documentação e ajudam em fóruns.\nCódigo aberto: permite trabalhar com inumeras possibilidades nas análises de dados, visualização de dados utilizando diferentes componentes gráficos, modelagem estatística, dentre outros recursos.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 1b.html",
    "href": "Projeto/FIP606_2024/Aula 1b.html",
    "title": "1. Software R e a IDE RStudio",
    "section": "",
    "text": "O Rstudio é uma IDE (ambiente de desenvolvimento integrado) para o R. Com sua utilização gratuita, o RStudio é uma excelente ferramenta para desenvolvimento em R, extremamente visual quando comparado com ambientes de outras linguagens e também com o console do R, e muito simples de se utilizar.\n\n\nI.Acesse o site oficial do R: CRAN (The Comprehensive R Archive Network).\nII.Escolha seu sistema operacional:\n\nex: Windows; macOS; Linux…\n\nIII.Baixe o instalador:\nIV.Execute o instalador:\nV.Siga as instruções do instalador:\nQualquer dúvida, seguir o passo a passo disponível no site que realizou o download do software (R-Project).\n\n\n1° Abrir o R, 2° verificar a versão do r no console do R, digitando ‘version’ e clicando Enter."
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 1b.html#como-instalar-o-r",
    "href": "Projeto/FIP606_2024/Aula 1b.html#como-instalar-o-r",
    "title": "1. Software R e a IDE RStudio",
    "section": "",
    "text": "I.Acesse o site oficial do R: CRAN (The Comprehensive R Archive Network).\nII.Escolha seu sistema operacional:\n\nex: Windows; macOS; Linux…\n\nIII.Baixe o instalador:\nIV.Execute o instalador:\nV.Siga as instruções do instalador:\nQualquer dúvida, seguir o passo a passo disponível no site que realizou o download do software (R-Project).\n\n\n1° Abrir o R, 2° verificar a versão do r no console do R, digitando ‘version’ e clicando Enter."
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2.html",
    "href": "Projeto/FIP606_2024/Aula 2.html",
    "title": "1. RStudio:",
    "section": "",
    "text": "A interface do RStudio é normalmente dividida em 4 partes, conforme apresentado na imagem abaixo pelos números 1, 2, 3 e 4.\n\n\n  format width height colorspace matte filesize density\n1    PNG  1366    768       sRGB FALSE   107329   38x38\n\n\n\n\n\n1 - script, nessa janela é possível colocar em cada linha códigos e o Enteré utilizado para quebra de linha. Para executar o comando usa Control+Enter ou clique em Run (⊳) no canto superior direito do chunck.\n2 - console, trabalhar no console é muito limitado, pois as instruções devem ser inseridas uma por uma. Para executar o comando preciona Ènter.\n3 - Environment, é onde ficam armazendos os objetos criados, bases de dados importadas, etc. History, onde fica o histórico dos comandos executados.\n4 - Files, Plots, Packages, Help, Viewer, em Files encontra as pastas e arquivos carregados no RStudio. A visualização de grãficos em Plots, buscar pacotes instalados em Packages, para saber mais sobre as funções em Help e visualizar imagens carregadas em Viewer.\n\n\nPara isso pode ser criado um projeto clicando na barra de ferramentas superior em File e em seguida em New project.\n\n\n  format width height colorspace matte filesize density\n1    PNG  1366    768       sRGB FALSE   113790   38x38\n\n\n\n\n\nAssim você pode trabalhar com diferentes cojuntos de dados ao mesmo tempo sem que ocorra a interveção ou conflitos entre os conjuntos de dados. Recomenda para cada trabalho, separar em projetos. Ex: um projeto para conjuntos de dados referente a pesquisa Monitoramento da sensibilidade in vitro de Colletotrichum truncatum à fungicidas e outro projeto para o conjunto de dados da pesquisa Épocas de aplicações de fungicidas multissítios no controle de mancha alvo na cultura da soja.\nApós criar o projeto inicia o trabalho com o conjunto de dados, criando uma página para desenvolver o spript, clicando em File e depois em New File, podendo selecionar Quarto Document... ou R Markdown.\n\n\n  format width height colorspace matte filesize density\n1    PNG  1366    768       sRGB FALSE   110539   38x38\n\n\n\n\n\n\n\n\nO Quarto é uma versão mais avançada e atualizada do R Markdown, com novos recursos, podendo renderizar a maioria dos arquivos **.Rmd** existentes sem modificação, possibilitando a criação de relatórios ou textos em diferentes formatos (HTML, PDF, Word e outros). Nessa página Web foi utilizado apenas Quarto Document.\n\n\n\nAcima foi inserido um chuck. Chunck é um bloco de código dentro de um documento R Markdown (ou Quarto) que permite a execução de código R ou de outros idiomas suportados (como Python, SQL, etc.) dentro de um documento de texto. Um atalho que pode ser usado para sua criação é o Ctrl + Alt + I ou inserir o chunck conforme mostra a imagem a seguir:\n\n\n  format width height colorspace matte filesize density\n1    PNG  1366    768       sRGB FALSE    99562   38x38\n\n\n\n\n\n\n\n\nNegrito: inserir antes e depois do texto que deseja apresentar em negrito, dois asteriscos  **. Itálico: inserir antes e depois do texto que deseja apresentar em itálico, um asteriscos * *. Título e subtítulos: Fora do chunck, para visualizar o texto como título, colocar um # antes e um # depois do texto. Para subtítulos, colocar dois ## antes e dois ## depois texto. Comentários: dentro do chunck escrever comentários utilizando antes do texto #. Texto: para rodar o código do chunck como texto, ex: nome da planilha excel, utilizar aspas duplas “ antes e depois do texto. Funções: fora do chunck, para destacar uma função no texto, inserir antes e depois do texto uma aspas `.\n\n\n\nQuando queremos atribuir um valor para algum nome, podemos utilizar &lt;-. Desse modo, se quisermos trabalhar com esses valores ou conjunto de valores atribuídos a um nome, podemos utilizar diretamente o nome, sem precisar repetir o valor.\n\nx &lt;- 10\nx\n\n[1] 10\n\ny &lt;- x*10\ny\n\n[1] 100\n\nz &lt;- x*y\nz\n\n[1] 1000\n\n\n\n\n\nPara criar um conjunto de valores, pode-se utilizar c()e colocar os valores desejados. Caso os valores sejam contínuos, pode-se agrupá-los usando :, desse modo o conjunto será formado por todos os valores que estão entre os dois números colocados.\n\nA &lt;- c(1:10)\nA \n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nB &lt;- c(11:20)\nB\n\n [1] 11 12 13 14 15 16 17 18 19 20\n\n\n\n\n\nO data frame é é o objeto que guarda o conjunto de dados na forma de tabela (tabulares ou planos). Podendo armazenar vetores de diferentes tipos (caracteres, numéricos, lógico e etc) nas suas colunas. Ele pode ser criado por meio da junção de dois ou mais conjunto de dados, usando a função data.frame(), mas, para isso, o número de valores presentes nos conjuntos deve ser o mesmo.\n\ndf &lt;- data.frame(A,B)\ndf \n\n    A  B\n1   1 11\n2   2 12\n3   3 13\n4   4 14\n5   5 15\n6   6 16\n7   7 17\n8   8 18\n9   9 19\n10 10 20\n\n\n\n\n\nUtilizado quando desejar que todas as funções executadas estejam se referindo a um determinado data frame sem precisar chamá-lo repetidamente, podemos usar um pipe, precisando Ctrl+Shift+M. O pipe indica que todas as funções abaixo dele estão se referindo ao data frame especificado.\n\ndf2 &lt;- cars\ncars\n\n   speed dist\n1      4    2\n2      4   10\n3      7    4\n4      7   22\n5      8   16\n6      9   10\n7     10   18\n8     10   26\n9     10   34\n10    11   17\n11    11   28\n12    12   14\n13    12   20\n14    12   24\n15    12   28\n16    13   26\n17    13   34\n18    13   34\n19    13   46\n20    14   26\n21    14   36\n22    14   60\n23    14   80\n24    15   20\n25    15   26\n26    15   54\n27    16   32\n28    16   40\n29    17   32\n30    17   40\n31    17   50\n32    18   42\n33    18   56\n34    18   76\n35    18   84\n36    19   36\n37    19   46\n38    19   68\n39    20   32\n40    20   48\n41    20   52\n42    20   56\n43    20   64\n44    22   66\n45    23   54\n46    24   70\n47    24   92\n48    24   93\n49    24  120\n50    25   85\n\n\n\n\n\nÉ utilizado $ para criar uma nova coluna dentro do data frame, como mostra a seguir:\n\ndf2$dist2 &lt;- c(1:50)\ndf2\n\n   speed dist dist2\n1      4    2     1\n2      4   10     2\n3      7    4     3\n4      7   22     4\n5      8   16     5\n6      9   10     6\n7     10   18     7\n8     10   26     8\n9     10   34     9\n10    11   17    10\n11    11   28    11\n12    12   14    12\n13    12   20    13\n14    12   24    14\n15    12   28    15\n16    13   26    16\n17    13   34    17\n18    13   34    18\n19    13   46    19\n20    14   26    20\n21    14   36    21\n22    14   60    22\n23    14   80    23\n24    15   20    24\n25    15   26    25\n26    15   54    26\n27    16   32    27\n28    16   40    28\n29    17   32    29\n30    17   40    30\n31    17   50    31\n32    18   42    32\n33    18   56    33\n34    18   76    34\n35    18   84    35\n36    19   36    36\n37    19   46    37\n38    19   68    38\n39    20   32    39\n40    20   48    40\n41    20   52    41\n42    20   56    42\n43    20   64    43\n44    22   66    44\n45    23   54    45\n46    24   70    46\n47    24   92    47\n48    24   93    48\n49    24  120    49\n50    25   85    50\n\n\n\nlibrary(tidyverse)\n\ndf2 |&gt;\n  mutate(dist3 = dist2+1) |&gt; \n  select(1)\n\n   speed\n1      4\n2      4\n3      7\n4      7\n5      8\n6      9\n7     10\n8     10\n9     10\n10    11\n11    11\n12    12\n13    12\n14    12\n15    12\n16    13\n17    13\n18    13\n19    13\n20    14\n21    14\n22    14\n23    14\n24    15\n25    15\n26    15\n27    16\n28    16\n29    17\n30    17\n31    17\n32    18\n33    18\n34    18\n35    18\n36    19\n37    19\n38    19\n39    20\n40    20\n41    20\n42    20\n43    20\n44    22\n45    23\n46    24\n47    24\n48    24\n49    24\n50    25\n\n\n\n\n\nPara transformar o documento .qmd em HTML ou em outros formatos, é necessário renderizar o documento. Para isso basta clicar no menu superior em Render para que o documento ou site seja criado.\n\n\n# A tibble: 1 × 7\n  format width height colorspace matte filesize density\n  &lt;chr&gt;  &lt;int&gt;  &lt;int&gt; &lt;chr&gt;      &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;  \n1 PNG     1366    768 sRGB       FALSE    89045 38x38"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2.html#trabalhe-de-forma-organizada",
    "href": "Projeto/FIP606_2024/Aula 2.html#trabalhe-de-forma-organizada",
    "title": "1. RStudio:",
    "section": "",
    "text": "Para isso pode ser criado um projeto clicando na barra de ferramentas superior em File e em seguida em New project.\n\n\n  format width height colorspace matte filesize density\n1    PNG  1366    768       sRGB FALSE   113790   38x38\n\n\n\n\n\nAssim você pode trabalhar com diferentes cojuntos de dados ao mesmo tempo sem que ocorra a interveção ou conflitos entre os conjuntos de dados. Recomenda para cada trabalho, separar em projetos. Ex: um projeto para conjuntos de dados referente a pesquisa Monitoramento da sensibilidade in vitro de Colletotrichum truncatum à fungicidas e outro projeto para o conjunto de dados da pesquisa Épocas de aplicações de fungicidas multissítios no controle de mancha alvo na cultura da soja.\nApós criar o projeto inicia o trabalho com o conjunto de dados, criando uma página para desenvolver o spript, clicando em File e depois em New File, podendo selecionar Quarto Document... ou R Markdown.\n\n\n  format width height colorspace matte filesize density\n1    PNG  1366    768       sRGB FALSE   110539   38x38"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2.html#diferença-de-quarto-document-e-r-markdown",
    "href": "Projeto/FIP606_2024/Aula 2.html#diferença-de-quarto-document-e-r-markdown",
    "title": "1. RStudio:",
    "section": "",
    "text": "O Quarto é uma versão mais avançada e atualizada do R Markdown, com novos recursos, podendo renderizar a maioria dos arquivos **.Rmd** existentes sem modificação, possibilitando a criação de relatórios ou textos em diferentes formatos (HTML, PDF, Word e outros). Nessa página Web foi utilizado apenas Quarto Document."
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2.html#chunk",
    "href": "Projeto/FIP606_2024/Aula 2.html#chunk",
    "title": "1. RStudio:",
    "section": "",
    "text": "Acima foi inserido um chuck. Chunck é um bloco de código dentro de um documento R Markdown (ou Quarto) que permite a execução de código R ou de outros idiomas suportados (como Python, SQL, etc.) dentro de um documento de texto. Um atalho que pode ser usado para sua criação é o Ctrl + Alt + I ou inserir o chunck conforme mostra a imagem a seguir:\n\n\n  format width height colorspace matte filesize density\n1    PNG  1366    768       sRGB FALSE    99562   38x38"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2.html#ferramentas-de-texto",
    "href": "Projeto/FIP606_2024/Aula 2.html#ferramentas-de-texto",
    "title": "1. RStudio:",
    "section": "",
    "text": "Negrito: inserir antes e depois do texto que deseja apresentar em negrito, dois asteriscos  **. Itálico: inserir antes e depois do texto que deseja apresentar em itálico, um asteriscos * *. Título e subtítulos: Fora do chunck, para visualizar o texto como título, colocar um # antes e um # depois do texto. Para subtítulos, colocar dois ## antes e dois ## depois texto. Comentários: dentro do chunck escrever comentários utilizando antes do texto #. Texto: para rodar o código do chunck como texto, ex: nome da planilha excel, utilizar aspas duplas “ antes e depois do texto. Funções: fora do chunck, para destacar uma função no texto, inserir antes e depois do texto uma aspas `."
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2.html#atribuição-de-valores",
    "href": "Projeto/FIP606_2024/Aula 2.html#atribuição-de-valores",
    "title": "1. RStudio:",
    "section": "",
    "text": "Quando queremos atribuir um valor para algum nome, podemos utilizar &lt;-. Desse modo, se quisermos trabalhar com esses valores ou conjunto de valores atribuídos a um nome, podemos utilizar diretamente o nome, sem precisar repetir o valor.\n\nx &lt;- 10\nx\n\n[1] 10\n\ny &lt;- x*10\ny\n\n[1] 100\n\nz &lt;- x*y\nz\n\n[1] 1000"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2.html#conjunto-de-valores",
    "href": "Projeto/FIP606_2024/Aula 2.html#conjunto-de-valores",
    "title": "1. RStudio:",
    "section": "",
    "text": "Para criar um conjunto de valores, pode-se utilizar c()e colocar os valores desejados. Caso os valores sejam contínuos, pode-se agrupá-los usando :, desse modo o conjunto será formado por todos os valores que estão entre os dois números colocados.\n\nA &lt;- c(1:10)\nA \n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nB &lt;- c(11:20)\nB\n\n [1] 11 12 13 14 15 16 17 18 19 20"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2.html#data-frame",
    "href": "Projeto/FIP606_2024/Aula 2.html#data-frame",
    "title": "1. RStudio:",
    "section": "",
    "text": "O data frame é é o objeto que guarda o conjunto de dados na forma de tabela (tabulares ou planos). Podendo armazenar vetores de diferentes tipos (caracteres, numéricos, lógico e etc) nas suas colunas. Ele pode ser criado por meio da junção de dois ou mais conjunto de dados, usando a função data.frame(), mas, para isso, o número de valores presentes nos conjuntos deve ser o mesmo.\n\ndf &lt;- data.frame(A,B)\ndf \n\n    A  B\n1   1 11\n2   2 12\n3   3 13\n4   4 14\n5   5 15\n6   6 16\n7   7 17\n8   8 18\n9   9 19\n10 10 20"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2.html#pipe",
    "href": "Projeto/FIP606_2024/Aula 2.html#pipe",
    "title": "1. RStudio:",
    "section": "",
    "text": "Utilizado quando desejar que todas as funções executadas estejam se referindo a um determinado data frame sem precisar chamá-lo repetidamente, podemos usar um pipe, precisando Ctrl+Shift+M. O pipe indica que todas as funções abaixo dele estão se referindo ao data frame especificado.\n\ndf2 &lt;- cars\ncars\n\n   speed dist\n1      4    2\n2      4   10\n3      7    4\n4      7   22\n5      8   16\n6      9   10\n7     10   18\n8     10   26\n9     10   34\n10    11   17\n11    11   28\n12    12   14\n13    12   20\n14    12   24\n15    12   28\n16    13   26\n17    13   34\n18    13   34\n19    13   46\n20    14   26\n21    14   36\n22    14   60\n23    14   80\n24    15   20\n25    15   26\n26    15   54\n27    16   32\n28    16   40\n29    17   32\n30    17   40\n31    17   50\n32    18   42\n33    18   56\n34    18   76\n35    18   84\n36    19   36\n37    19   46\n38    19   68\n39    20   32\n40    20   48\n41    20   52\n42    20   56\n43    20   64\n44    22   66\n45    23   54\n46    24   70\n47    24   92\n48    24   93\n49    24  120\n50    25   85"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2.html#criar-coluna-dentro-do-data-frame",
    "href": "Projeto/FIP606_2024/Aula 2.html#criar-coluna-dentro-do-data-frame",
    "title": "1. RStudio:",
    "section": "",
    "text": "É utilizado $ para criar uma nova coluna dentro do data frame, como mostra a seguir:\n\ndf2$dist2 &lt;- c(1:50)\ndf2\n\n   speed dist dist2\n1      4    2     1\n2      4   10     2\n3      7    4     3\n4      7   22     4\n5      8   16     5\n6      9   10     6\n7     10   18     7\n8     10   26     8\n9     10   34     9\n10    11   17    10\n11    11   28    11\n12    12   14    12\n13    12   20    13\n14    12   24    14\n15    12   28    15\n16    13   26    16\n17    13   34    17\n18    13   34    18\n19    13   46    19\n20    14   26    20\n21    14   36    21\n22    14   60    22\n23    14   80    23\n24    15   20    24\n25    15   26    25\n26    15   54    26\n27    16   32    27\n28    16   40    28\n29    17   32    29\n30    17   40    30\n31    17   50    31\n32    18   42    32\n33    18   56    33\n34    18   76    34\n35    18   84    35\n36    19   36    36\n37    19   46    37\n38    19   68    38\n39    20   32    39\n40    20   48    40\n41    20   52    41\n42    20   56    42\n43    20   64    43\n44    22   66    44\n45    23   54    45\n46    24   70    46\n47    24   92    47\n48    24   93    48\n49    24  120    49\n50    25   85    50\n\n\n\nlibrary(tidyverse)\n\ndf2 |&gt;\n  mutate(dist3 = dist2+1) |&gt; \n  select(1)\n\n   speed\n1      4\n2      4\n3      7\n4      7\n5      8\n6      9\n7     10\n8     10\n9     10\n10    11\n11    11\n12    12\n13    12\n14    12\n15    12\n16    13\n17    13\n18    13\n19    13\n20    14\n21    14\n22    14\n23    14\n24    15\n25    15\n26    15\n27    16\n28    16\n29    17\n30    17\n31    17\n32    18\n33    18\n34    18\n35    18\n36    19\n37    19\n38    19\n39    20\n40    20\n41    20\n42    20\n43    20\n44    22\n45    23\n46    24\n47    24\n48    24\n49    24\n50    25"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2.html#criar-arquivo-html",
    "href": "Projeto/FIP606_2024/Aula 2.html#criar-arquivo-html",
    "title": "1. RStudio:",
    "section": "",
    "text": "Para transformar o documento .qmd em HTML ou em outros formatos, é necessário renderizar o documento. Para isso basta clicar no menu superior em Render para que o documento ou site seja criado.\n\n\n# A tibble: 1 × 7\n  format width height colorspace matte filesize density\n  &lt;chr&gt;  &lt;int&gt;  &lt;int&gt; &lt;chr&gt;      &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;  \n1 PNG     1366    768 sRGB       FALSE    89045 38x38"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2b.html",
    "href": "Projeto/FIP606_2024/Aula 2b.html",
    "title": "1. Instalação",
    "section": "",
    "text": "Pacotes são coleções de funções R, dados e código compilado em um formato bem definido, criados para adicionar funcionalidades específicas. Será mostrados os principais pacotes utilizados em análises e visualização de dados."
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2b.html#carregar-pacotes",
    "href": "Projeto/FIP606_2024/Aula 2b.html#carregar-pacotes",
    "title": "1. Instalação",
    "section": "2. Carregar pacotes",
    "text": "2. Carregar pacotes\nUtilize a função library(), inserindo dentro do parênteses o nome do pacote."
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2c.html",
    "href": "Projeto/FIP606_2024/Aula 2c.html",
    "title": "1. Importação de dados",
    "section": "",
    "text": "Para analisar dados um dos primeiros passos é criar, carregar ou importar um conjunto de dados no ambiente R. É muito utilizado o dataframe, que é o objeto que guarda o conjunto de dados na forma de tabela (tabulares ou planos). Podendo armazenar vetores de diferentes tipos (caracteres, numéricos, lógico e etc) nas suas colunas. No segundo chunck desse script foi atribuído um dataframe."
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2c.html#carregar-dados-planilha-excel-salva-no-disco-local",
    "href": "Projeto/FIP606_2024/Aula 2c.html#carregar-dados-planilha-excel-salva-no-disco-local",
    "title": "1. Importação de dados",
    "section": "2.1 Carregar dados planilha excel salva no disco local",
    "text": "2.1 Carregar dados planilha excel salva no disco local\nFoi instalado o pacote readxl e carregou para lêr os dados diretamente em excel. O comando para lêr o arquivo é read_excel(\"nome_do_arquivo\"). No dataframe df21 foi utilizado sheet para especificar qual planilha do arquivo excel dados-diversos carregar.\n\nlibrary(readxl) \ndf2 &lt;- read_excel(\"dados_diversos.xlsx\") \ndf21 &lt;- read_excel(\"dados_diversos.xlsx\", sheet = \"escala\") \n#df21 &lt;- read_excel(\"dados-diversos.xlsx\", \"escala\") \n#df21 &lt;- read_excel(\"dados-diversos.xlsx\", 2)\n\nUtilizou o pacote tidyverse para carregar os dados. df3 é o dataframe da planilha dados-diversos.csv.\n\nlibrary(tidyverse) \ndf3 &lt;- read_csv(\"dados-diversos.csv\")"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 2c.html#carregar-planilha-do-google-drive",
    "href": "Projeto/FIP606_2024/Aula 2c.html#carregar-planilha-do-google-drive",
    "title": "1. Importação de dados",
    "section": "2.2 Carregar planilha do google drive",
    "text": "2.2 Carregar planilha do google drive\nUtilizar os pacotes gsheet e googlesheet4 para utilizar o banco de dados diretamente do google drive.\nPara o gsheet utiliza gsheet2tb para baixar o banco de dados no objeto df4. Copiar o link da planilha online e colar entre aspas dentro dos parêntes, como apresentado no chunck abaixo.\n\nlibrary(gsheet) \ndf4 &lt;- gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1aID5Dh6PlBVCKzU1j7k-WA6zuWQWE2NhtWEgdJtt5iA/edit?usp=sharing\")  \ndf41 &lt;- gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1aID5Dh6PlBVCKzU1j7k-WA6zuWQWE2NhtWEgdJtt5iA/edit?usp=sharing\", sheetid = \"2\") \n\nPara o googlesheets4 o nome da função é read_sheet(\"\"). Permite baixar e escrever nos arquivos.\n\nlibrary(googlesheets4) \ndf5 &lt;- read_sheet(\"https://docs.google.com/spreadsheets/d/1aID5Dh6PlBVCKzU1j7k-WA6zuWQWE2NhtWEgdJtt5iA/edit?usp=sharing\")"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 3.html",
    "href": "Projeto/FIP606_2024/Aula 3.html",
    "title": "1. ggplot",
    "section": "",
    "text": "Vamos utilizar o ggplot2 para poder fazer um gráfico para análise exploratória das variáveis. Com o geom_point mostra os pontos dentro da mesma variável, mas estes podem estar sobrepostos, para isso utilizamos o geom_jitter para poder desagregar os pontos dentro e observar melhor os dados.\nPode adicionar camadas também, quando coloca (+) outro parâmetro como o ´geom_boxplot`. A ordem altera como a camada será exposta, se ela ficará acima ou abaixo. O primeiro a ser chamado ficará na camada mais abaixo a próxima ficara acima desta, a próxima que for criada ficara acima das demais e assim por diante.\nPara não duplicar o outlier, podemos tirar o outlier com outlier.colour = NA.\nPodemos utilizar temas, para atender a um jornal específico, como g2 + theme_bw(), o tema fica preto e branco algo mais clean e científico. Tem outros como o theme_classic.\n\n\n\nlibrary(gsheet) \ndf4 &lt;- gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1aID5Dh6PlBVCKzU1j7k-WA6zuWQWE2NhtWEgdJtt5iA/edit?usp=sharing\") \n\n\n\n\n\nlibrary(ggplot2)\ng1 &lt;- df4 |&gt;\n  ggplot(aes(trat, comp))+\n  geom_point(color = \"darkgreen\", shape = 2, size = 3)\ng1 + theme_classic()+\n  labs(x = \"Tratamento\",\n       y = \"Comprimento\",\n       title = \"Meu primeiro ggplot\",\n       caption = \"Fonte: Dados diversos\")\n\n\n\ng2 &lt;- df4 |&gt;\n  ggplot(aes(trat, comp))+\n  geom_boxplot(outlier.colour = NA,\n               fill = \"orange\")+\n  geom_jitter(width = 0.05,\n              color = \"darkblue\",\n              shape = 3,\n              size = 2)\ng2 + theme_bw() +\n  #ylim(0,20) #Ele faz a mesma coisa que o de baixo\n  scale_y_continuous(limits = c(0,20),\n                     n.breaks = 5) #n.breaks é o número de quebras, se colocar breaks apenas, fica só a linha correspondente aquele número.\n\n\n\nggsave(\"plot1.png\", bg = \"white\")"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 3.html#carregar-conjuntos-de-dados",
    "href": "Projeto/FIP606_2024/Aula 3.html#carregar-conjuntos-de-dados",
    "title": "1. ggplot",
    "section": "",
    "text": "library(gsheet) \ndf4 &lt;- gsheet2tbl(\"https://docs.google.com/spreadsheets/d/1aID5Dh6PlBVCKzU1j7k-WA6zuWQWE2NhtWEgdJtt5iA/edit?usp=sharing\")"
  },
  {
    "objectID": "Projeto/FIP606_2024/Aula 3.html#construção-de-gráficos",
    "href": "Projeto/FIP606_2024/Aula 3.html#construção-de-gráficos",
    "title": "1. ggplot",
    "section": "",
    "text": "library(ggplot2)\ng1 &lt;- df4 |&gt;\n  ggplot(aes(trat, comp))+\n  geom_point(color = \"darkgreen\", shape = 2, size = 3)\ng1 + theme_classic()+\n  labs(x = \"Tratamento\",\n       y = \"Comprimento\",\n       title = \"Meu primeiro ggplot\",\n       caption = \"Fonte: Dados diversos\")\n\n\n\ng2 &lt;- df4 |&gt;\n  ggplot(aes(trat, comp))+\n  geom_boxplot(outlier.colour = NA,\n               fill = \"orange\")+\n  geom_jitter(width = 0.05,\n              color = \"darkblue\",\n              shape = 3,\n              size = 2)\ng2 + theme_bw() +\n  #ylim(0,20) #Ele faz a mesma coisa que o de baixo\n  scale_y_continuous(limits = c(0,20),\n                     n.breaks = 5) #n.breaks é o número de quebras, se colocar breaks apenas, fica só a linha correspondente aquele número.\n\n\n\nggsave(\"plot1.png\", bg = \"white\")"
  },
  {
    "objectID": "Projeto/FIP606_2024/index.html",
    "href": "Projeto/FIP606_2024/index.html",
    "title": "Bem-vindos!",
    "section": "",
    "text": "Olá, sou o Lucas Versari e é uma satisfação compartilhar essa página!\nSobre mim\nEngenheiro Agrônomo pela Universidade Federal de Mato Grosso (UFMT) e atualmente mestrando em Fitopatologia na Universidade Federal de Viçosa (UFV). Durante a Graduação foi bolsista de iniciação científica da Embrapa Agrossilvipastoril em Sinop-MT, na área da Fitopatologia, por dois anos. Trabalhou por 1 ano e 6 meses na EPR Consultoria e Pesquisa Agronômica. No momento desenvolve pesquisas no Instituto de Biotecnologia Aplicada à Agropecuária (BIOAGRO/UFV) no Laboratório de Genética e Genômica da Interação Planta-Patógeno.\nSobre o site\nTêm como finalidade disponibilizar o conteúdo das aulas de Análises e Visualização de Dados em Fitopatologia, ministrada pelo Professor Dr. Emerson Medeiros Del Ponte.\nEsse site auxiliará com informações e passo a passo, desde a iniciação em RStudio até mesmo em interpretação e visualização de dados.\nBons estudos!\n\n\n\n Back to top"
  },
  {
    "objectID": "projeto_final (1) - Copia.html",
    "href": "projeto_final (1) - Copia.html",
    "title": "Projeto Final da Disciplina de Análise e Visualização de Dados em Fitopatologia - FIP606",
    "section": "",
    "text": "O dataset consiste em…………………….. ENROLAR……\n\noptions(\"install.lock\"=FALSE)\n\n\nlibrary(rnaturalearthhires)\nlibrary(rnaturalearth)\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(ggiraph)\n\n# Função para converter graus, minutos e segundos para graus decimais\ndms_to_decimal &lt;- function(dms, direction) {\n  dms_split &lt;- str_split(dms, \"[°′”’\\\"]\")[[1]]\n  degrees &lt;- as.numeric(dms_split[1])\n  minutes &lt;- as.numeric(dms_split[2])\n  seconds &lt;- as.numeric(dms_split[3])\n  decimal &lt;- degrees + minutes / 60 + seconds / 3600\n  if (direction %in% c(\"S\", \"W\")) {\n    decimal &lt;- -decimal\n  }\n  return(decimal)\n}\n\n# Dados das fazendas\nfazendas &lt;- data.frame(\n  nome = c(\"1, 2 e 3 - Águas de Março\", \"4 - Harmonia\", \"5 - Camila\", \"6 - Tamara/Juliano\", \"7 - Sinai\", \n           \"8 - Chapadão\", \"9 - Geuzilene\"),\n  cidade = c(\"Sapezal - MT\", \"Sapezal - MT\", \"Sapezal - MT\", \"Diamantino - MT\", \"Santa Terezinha - MT\", \"Matupá-MT\", \"Querência - MT\"),\n  lat = c(\"13°03’59”S\", \"13°49’24”S\", \"13°32’23”S\", \"14°10’49”S\", \"10°17”20”S\", \n          \"10°7’27,6”S\", \"12°20’27”S\"),\n  lon = c(\"58°38’14”W\", \"58°45’35”W\", \"58°42’47”W\", \"56°32’46”W\", \"50°47’53”W\", \"54°58’33”W\", \"52°22’45”W\")\n)\n\n# Converter coordenadas para graus decimais\nfazendas &lt;- fazendas %&gt;%\n  mutate(lat_decimal = mapply(dms_to_decimal, str_replace_all(lat, \"[^0-9°′”’\\\"]\", \"\"), ifelse(grepl(\"S\", lat), \"S\", \"N\")),\n         lon_decimal = mapply(dms_to_decimal, str_replace_all(lon, \"[^0-9°′”’\\\"]\", \"\"), ifelse(grepl(\"W\", lon), \"W\", \"E\")))\n\n# Transformando os pontos em um objeto sf\nfazendas_sf &lt;- st_as_sf(fazendas, coords = c(\"lon_decimal\", \"lat_decimal\"), crs = 4326)\n\n# Dados do Brasil\nBRA &lt;- ne_states(country = \"Brazil\", returnclass = \"sf\")\n\n# Plotando o mapa com os pontos e a legenda\ngg &lt;- ggplot(BRA) +\n  geom_sf(fill = \"white\", color = \"black\", size = 0.3) +\n  geom_sf_interactive(data = fazendas_sf, aes(color = nome, tooltip = paste(\"Nome:\", nome, \"&lt;br&gt;Cidade:\", cidade, \"&lt;br&gt;Coordenadas:\", lat, lon)), size = 3) +\n  theme_minimal() +\n  labs(title = \"Mapa de pontos de coleta dos isolados\",\n       color = \"Tratamento/Fazenda\")\n\n# Renderizando o gráfico interativo\ngirafe(ggobj = gg)\n\n\n\n\n\n\n\nPara a leitura e importação de dados em Excel, utilizaremos o pacote readxl, para isso é necessário que instale e carregue este pacote. O pacote readxl, permite a leitura de arquivos Excel (.xlsx) sendo especialmente útil para importar dados que são frequentemente armazenados em planilhas.\n\nlibrary(readxl)\ndados &lt;- read_excel(\"SensibilidadeCory2020.xlsx\")\nhead(dados)\n\n# A tibble: 6 × 7\n  trat   aval isolado  dias   rep  dose  diam\n  &lt;chr&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Fox₢      1       1     2     1     0  23.5\n2 Fox₢      1       1     2     2     0  21.4\n3 Fox₢      1       1     2     3     0  20.0\n4 Fox₢      1       2     2     1     0  25.6\n5 Fox₢      1       2     2     2     0  26.4\n6 Fox₢      1       2     2     3     0  26.3\n\n\n\n\n\n\nlibrary(ggsci)\n\n# Médias\nmedias &lt;- dados |&gt; \n  group_by(trat,dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam)) |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = dose, y = media_diam, color = factor(isolado), group = isolado)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~aval)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Concentração\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Isolados\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\n\n# Médias\nmedias &lt;- dados |&gt; \n  group_by(trat, dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam)) |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = dose, y = media_diam, color = factor(aval), group = aval)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~isolado)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Concentração\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Avaliação\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\n\nmedias &lt;- dados |&gt; \n  group_by(trat, dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam)) |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = aval, y = media_diam, color = factor(dose), group = dose)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~isolado)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Avaliações\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Dose\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\nMODELOS DE REGRESSÃO - USANDO DIAM\n\nlibrary(dplyr)\nlibrary(drc)\nlibrary(ggplot2)\n\n# Função para ajustar múltiplos modelos de dose-resposta e selecionar o melhor modelo\najustar_e_selecionar_melhor_modelo &lt;- function(dados, tratamento, isolado, avaliacao) {\n  data_filtrado &lt;- dados %&gt;%\n    filter(trat == tratamento, isolado == isolado, aval == avaliacao) %&gt;%\n    group_by(dose) %&gt;%\n    slice_head(n = 3) %&gt;%\n    ungroup()\n  \n  # Ajustar os modelos\n  modelo1 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = LN.3()), error = function(e) NULL)\n  modelo2 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = LL.3()), error = function(e) NULL)\n  modelo3 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = W1.3()), error = function(e) NULL)\n  modelo4 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = W2.3()), error = function(e) NULL)\n  \n  # Selecionar o melhor modelo com base no AIC\n  modelos &lt;- list(LN.3 = modelo1, LL.3 = modelo2, W1.3 = modelo3, W2.3 = modelo4)\n  modelos_validos &lt;- modelos[!sapply(modelos, is.null)]\n  \n  if (length(modelos_validos) &gt; 0) {\n    aic_values &lt;- sapply(modelos_validos, AIC, simplify = TRUE)\n    melhor_modelo &lt;- names(aic_values)[which.min(aic_values)]\n    return(list(modelo = modelos_validos[[melhor_modelo]], tipo = melhor_modelo, AIC = aic_values[melhor_modelo]))\n  } else {\n    return(NULL)\n  }\n}\n\n# Lista para armazenar os melhores modelos\nmelhores_modelos &lt;- list()\n\n# Lista de tratamentos, isolados e avaliações únicos\ntratamentos &lt;- unique(dados$trat)\nisolados &lt;- unique(dados$isolado)\navaliacoes &lt;- unique(dados$aval)\n\n# Iterar sobre todas as combinações de tratamento, isolado e avaliação\nfor (tratamento in tratamentos) {\n  for (isolado in isolados) {\n    for (avaliacao in avaliacoes) {\n      # Ajustar e selecionar o melhor modelo para a combinação atual\n      melhor_modelo &lt;- ajustar_e_selecionar_melhor_modelo(dados, tratamento, isolado, avaliacao)\n      chave &lt;- paste(tratamento, isolado, avaliacao, sep = \"-\")\n      melhores_modelos[[chave]] &lt;- melhor_modelo\n    }\n  }\n}\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\n# Função para plotar os dados e o melhor modelo\nplotar_melhor_modelo &lt;- function(dados, melhor_modelo, tratamento, isolado, avaliacao) {\n  data_filtrado &lt;- dados %&gt;%\n    filter(trat == tratamento, isolado == isolado, aval == avaliacao) %&gt;%\n    group_by(dose) %&gt;%\n    slice_head(n = 3) %&gt;%\n    ungroup()\n  \n  if (!is.null(melhor_modelo$modelo)) {\n    ggplot(data_filtrado, aes(x = dose, y = diam)) +\n      geom_point() +\n      geom_line(aes(y = predict(melhor_modelo$modelo)), color = 'blue') +\n      labs(title = paste(\"Tratamento:\", tratamento, \"Isolado:\", isolado, \"Avaliação:\", avaliacao),\n           subtitle = paste(\"Melhor modelo:\", melhor_modelo$tipo, \"AIC:\", round(melhor_modelo$AIC, 2)),\n           x = \"Dose\",\n           y = \"Diâmetro\") +\n      theme_minimal()\n  } else {\n    ggplot(data_filtrado, aes(x = dose, y = diam)) +\n      geom_point() +\n      labs(title = paste(\"Tratamento:\", tratamento, \"Isolado:\", isolado, \"Avaliação:\", avaliacao),\n           subtitle = \"Nenhum modelo ajustado\",\n           x = \"Dose\",\n           y = \"Diâmetro\") +\n      theme_minimal()\n  }\n}\n\n# Plotar os gráficos para cada combinação\nfor (chave in names(melhores_modelos)) {\n  comb &lt;- unlist(strsplit(chave, \"-\"))\n  tratamento &lt;- comb[1]\n  isolado &lt;- as.numeric(comb[2])\n  avaliacao &lt;- as.numeric(comb[3])\n  melhor_modelo &lt;- melhores_modelos[[chave]]\n  \n  print(plotar_melhor_modelo(dados, melhor_modelo, tratamento, isolado, avaliacao))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ec50estimator)\ndf_ec50_LN &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::LN.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor inicial em vmmin não é finito\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\n\ndf_ec50_LL &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::LL.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor não finito fornecido por optim\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\n\ndf_ec50_W1 &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::W1.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor inicial em vmmin não é finito\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\ndf_ec50_W2 &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::W2.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor não finito fornecido por optim\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\nhead(df_ec50_LL)\n\n  ID trat aval    Estimate Std..Error      Lower     Upper\n1  1 Fox₢    1  93.4421515  28.332137  34.522247 152.36206\n2  2 Fox₢    1   0.4936527   4.651691  -9.180068  10.16737\n3  3 Fox₢    1  72.3221270  10.466677  50.555481  94.08877\n4  4 Fox₢    1 160.2615254  37.834200  81.580999 238.94205\n5  5 Fox₢    1   2.8077983  27.435216 -54.246856  59.86245\n6  6 Fox₢    1  11.5289497   7.078668  -3.191946  26.24985\n\n\n\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Função para criar o gráfico de EC50\nplot_ec50 &lt;- function(df_ec50, model_name) {\n  # Filtrar valores não positivos e maiores que 100\n  df_ec50 &lt;- df_ec50 %&gt;% filter(Estimate &gt; 0 & Estimate &lt; 100)\n  \n  # Visualização dos EC50s\n  p &lt;- as.data.frame(df_ec50) %&gt;% \n    mutate(ID = as.numeric(ID)) %&gt;% \n    ggplot(aes(ID, Estimate, color = trat)) +\n    geom_point(size = 2) +\n    geom_errorbar(aes(ymin = Lower, ymax = Upper, color = trat), width = 0) +\n    facet_wrap(~aval, scales = \"free_x\", ncol = 2) +\n    scale_y_log10() +\n    scale_x_continuous(breaks = 1:9) +\n    scale_color_manual(values = c(\"darkred\", \"steelblue\", \"darkgreen\")) +\n    labs(x = \"Isolados\", y = \"EC50\", title = paste(\"Modelo:\", model_name)) +\n    theme_minimal() +\n    coord_flip() +\n    theme(axis.text.y = element_text(angle = 90, vjust = 0.5, hjust = 1), legend.position = \"bottom\")\n  \n  return(p)\n}\n\n# Criar gráficos para cada modelo\nplot_LN &lt;- plot_ec50(df_ec50_LN, \"LN.3\")\nplot_LL &lt;- plot_ec50(df_ec50_LL, \"LL.3\")\nplot_W1 &lt;- plot_ec50(df_ec50_W1, \"W1.3\")\nplot_W2 &lt;- plot_ec50(df_ec50_W2, \"W2.3\")\n\n# Exibir os gráficos\nprint(plot_LN)\n\n\n\nprint(plot_LL)\n\n\n\nprint(plot_W1)\n\n\n\nprint(plot_W2)"
  },
  {
    "objectID": "projeto_final (1) - Copia.html#carregando-o-dataset",
    "href": "projeto_final (1) - Copia.html#carregando-o-dataset",
    "title": "Projeto Final da Disciplina de Análise e Visualização de Dados em Fitopatologia - FIP606",
    "section": "",
    "text": "Para a leitura e importação de dados em Excel, utilizaremos o pacote readxl, para isso é necessário que instale e carregue este pacote. O pacote readxl, permite a leitura de arquivos Excel (.xlsx) sendo especialmente útil para importar dados que são frequentemente armazenados em planilhas.\n\nlibrary(readxl)\ndados &lt;- read_excel(\"SensibilidadeCory2020.xlsx\")\nhead(dados)\n\n# A tibble: 6 × 7\n  trat   aval isolado  dias   rep  dose  diam\n  &lt;chr&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Fox₢      1       1     2     1     0  23.5\n2 Fox₢      1       1     2     2     0  21.4\n3 Fox₢      1       1     2     3     0  20.0\n4 Fox₢      1       2     2     1     0  25.6\n5 Fox₢      1       2     2     2     0  26.4\n6 Fox₢      1       2     2     3     0  26.3"
  },
  {
    "objectID": "projeto_final (1) - Copia.html#visualização-de-dados",
    "href": "projeto_final (1) - Copia.html#visualização-de-dados",
    "title": "Projeto Final da Disciplina de Análise e Visualização de Dados em Fitopatologia - FIP606",
    "section": "",
    "text": "library(ggsci)\n\n# Médias\nmedias &lt;- dados |&gt; \n  group_by(trat,dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam)) |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = dose, y = media_diam, color = factor(isolado), group = isolado)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~aval)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Concentração\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Isolados\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\n\n# Médias\nmedias &lt;- dados |&gt; \n  group_by(trat, dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam)) |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = dose, y = media_diam, color = factor(aval), group = aval)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~isolado)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Concentração\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Avaliação\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\n\nmedias &lt;- dados |&gt; \n  group_by(trat, dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam)) |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = aval, y = media_diam, color = factor(dose), group = dose)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~isolado)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Avaliações\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Dose\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\nMODELOS DE REGRESSÃO - USANDO DIAM\n\nlibrary(dplyr)\nlibrary(drc)\nlibrary(ggplot2)\n\n# Função para ajustar múltiplos modelos de dose-resposta e selecionar o melhor modelo\najustar_e_selecionar_melhor_modelo &lt;- function(dados, tratamento, isolado, avaliacao) {\n  data_filtrado &lt;- dados %&gt;%\n    filter(trat == tratamento, isolado == isolado, aval == avaliacao) %&gt;%\n    group_by(dose) %&gt;%\n    slice_head(n = 3) %&gt;%\n    ungroup()\n  \n  # Ajustar os modelos\n  modelo1 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = LN.3()), error = function(e) NULL)\n  modelo2 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = LL.3()), error = function(e) NULL)\n  modelo3 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = W1.3()), error = function(e) NULL)\n  modelo4 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = W2.3()), error = function(e) NULL)\n  \n  # Selecionar o melhor modelo com base no AIC\n  modelos &lt;- list(LN.3 = modelo1, LL.3 = modelo2, W1.3 = modelo3, W2.3 = modelo4)\n  modelos_validos &lt;- modelos[!sapply(modelos, is.null)]\n  \n  if (length(modelos_validos) &gt; 0) {\n    aic_values &lt;- sapply(modelos_validos, AIC, simplify = TRUE)\n    melhor_modelo &lt;- names(aic_values)[which.min(aic_values)]\n    return(list(modelo = modelos_validos[[melhor_modelo]], tipo = melhor_modelo, AIC = aic_values[melhor_modelo]))\n  } else {\n    return(NULL)\n  }\n}\n\n# Lista para armazenar os melhores modelos\nmelhores_modelos &lt;- list()\n\n# Lista de tratamentos, isolados e avaliações únicos\ntratamentos &lt;- unique(dados$trat)\nisolados &lt;- unique(dados$isolado)\navaliacoes &lt;- unique(dados$aval)\n\n# Iterar sobre todas as combinações de tratamento, isolado e avaliação\nfor (tratamento in tratamentos) {\n  for (isolado in isolados) {\n    for (avaliacao in avaliacoes) {\n      # Ajustar e selecionar o melhor modelo para a combinação atual\n      melhor_modelo &lt;- ajustar_e_selecionar_melhor_modelo(dados, tratamento, isolado, avaliacao)\n      chave &lt;- paste(tratamento, isolado, avaliacao, sep = \"-\")\n      melhores_modelos[[chave]] &lt;- melhor_modelo\n    }\n  }\n}\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\n# Função para plotar os dados e o melhor modelo\nplotar_melhor_modelo &lt;- function(dados, melhor_modelo, tratamento, isolado, avaliacao) {\n  data_filtrado &lt;- dados %&gt;%\n    filter(trat == tratamento, isolado == isolado, aval == avaliacao) %&gt;%\n    group_by(dose) %&gt;%\n    slice_head(n = 3) %&gt;%\n    ungroup()\n  \n  if (!is.null(melhor_modelo$modelo)) {\n    ggplot(data_filtrado, aes(x = dose, y = diam)) +\n      geom_point() +\n      geom_line(aes(y = predict(melhor_modelo$modelo)), color = 'blue') +\n      labs(title = paste(\"Tratamento:\", tratamento, \"Isolado:\", isolado, \"Avaliação:\", avaliacao),\n           subtitle = paste(\"Melhor modelo:\", melhor_modelo$tipo, \"AIC:\", round(melhor_modelo$AIC, 2)),\n           x = \"Dose\",\n           y = \"Diâmetro\") +\n      theme_minimal()\n  } else {\n    ggplot(data_filtrado, aes(x = dose, y = diam)) +\n      geom_point() +\n      labs(title = paste(\"Tratamento:\", tratamento, \"Isolado:\", isolado, \"Avaliação:\", avaliacao),\n           subtitle = \"Nenhum modelo ajustado\",\n           x = \"Dose\",\n           y = \"Diâmetro\") +\n      theme_minimal()\n  }\n}\n\n# Plotar os gráficos para cada combinação\nfor (chave in names(melhores_modelos)) {\n  comb &lt;- unlist(strsplit(chave, \"-\"))\n  tratamento &lt;- comb[1]\n  isolado &lt;- as.numeric(comb[2])\n  avaliacao &lt;- as.numeric(comb[3])\n  melhor_modelo &lt;- melhores_modelos[[chave]]\n  \n  print(plotar_melhor_modelo(dados, melhor_modelo, tratamento, isolado, avaliacao))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ec50estimator)\ndf_ec50_LN &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::LN.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor inicial em vmmin não é finito\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\n\ndf_ec50_LL &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::LL.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor não finito fornecido por optim\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\n\ndf_ec50_W1 &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::W1.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor inicial em vmmin não é finito\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\ndf_ec50_W2 &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::W2.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor não finito fornecido por optim\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\nhead(df_ec50_LL)\n\n  ID trat aval    Estimate Std..Error      Lower     Upper\n1  1 Fox₢    1  93.4421515  28.332137  34.522247 152.36206\n2  2 Fox₢    1   0.4936527   4.651691  -9.180068  10.16737\n3  3 Fox₢    1  72.3221270  10.466677  50.555481  94.08877\n4  4 Fox₢    1 160.2615254  37.834200  81.580999 238.94205\n5  5 Fox₢    1   2.8077983  27.435216 -54.246856  59.86245\n6  6 Fox₢    1  11.5289497   7.078668  -3.191946  26.24985\n\n\n\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Função para criar o gráfico de EC50\nplot_ec50 &lt;- function(df_ec50, model_name) {\n  # Filtrar valores não positivos e maiores que 100\n  df_ec50 &lt;- df_ec50 %&gt;% filter(Estimate &gt; 0 & Estimate &lt; 100)\n  \n  # Visualização dos EC50s\n  p &lt;- as.data.frame(df_ec50) %&gt;% \n    mutate(ID = as.numeric(ID)) %&gt;% \n    ggplot(aes(ID, Estimate, color = trat)) +\n    geom_point(size = 2) +\n    geom_errorbar(aes(ymin = Lower, ymax = Upper, color = trat), width = 0) +\n    facet_wrap(~aval, scales = \"free_x\", ncol = 2) +\n    scale_y_log10() +\n    scale_x_continuous(breaks = 1:9) +\n    scale_color_manual(values = c(\"darkred\", \"steelblue\", \"darkgreen\")) +\n    labs(x = \"Isolados\", y = \"EC50\", title = paste(\"Modelo:\", model_name)) +\n    theme_minimal() +\n    coord_flip() +\n    theme(axis.text.y = element_text(angle = 90, vjust = 0.5, hjust = 1), legend.position = \"bottom\")\n  \n  return(p)\n}\n\n# Criar gráficos para cada modelo\nplot_LN &lt;- plot_ec50(df_ec50_LN, \"LN.3\")\nplot_LL &lt;- plot_ec50(df_ec50_LL, \"LL.3\")\nplot_W1 &lt;- plot_ec50(df_ec50_W1, \"W1.3\")\nplot_W2 &lt;- plot_ec50(df_ec50_W2, \"W2.3\")\n\n# Exibir os gráficos\nprint(plot_LN)\n\n\n\nprint(plot_LL)\n\n\n\nprint(plot_W1)\n\n\n\nprint(plot_W2)"
  },
  {
    "objectID": "projeto_final (1).html",
    "href": "projeto_final (1).html",
    "title": "Projeto Final da Disciplina de Análise e Visualização de Dados em Fitopatologia - FIP606",
    "section": "",
    "text": "O dataset consiste em…………………….. ENROLAR……\n\nlibrary(rnaturalearthhires)\nlibrary(rnaturalearth)\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(ggiraph)\n\n# Função para converter graus, minutos e segundos para graus decimais\ndms_to_decimal &lt;- function(dms, direction) {\n  dms_split &lt;- str_split(dms, \"[°′”’\\\"]\")[[1]]\n  degrees &lt;- as.numeric(dms_split[1])\n  minutes &lt;- as.numeric(dms_split[2])\n  seconds &lt;- as.numeric(dms_split[3])\n  decimal &lt;- degrees + minutes / 60 + seconds / 3600\n  if (direction %in% c(\"S\", \"W\")) {\n    decimal &lt;- -decimal\n  }\n  return(decimal)\n}\n\n# Dados das fazendas\nfazendas &lt;- data.frame(\n  nome = c(\"1, 2 e 3 - Águas de Março\", \"4 - Harmonia\", \"5 - Camila\", \"6 - Tamara/Juliano\", \"7 - Sinai\", \n           \"8 - Chapadão\", \"9 - Geuzilene\"),\n  cidade = c(\"Sapezal - MT\", \"Sapezal - MT\", \"Sapezal - MT\", \"Diamantino - MT\", \"Santa Terezinha - MT\", \"Matupá-MT\", \"Querência - MT\"),\n  lat = c(\"13°03’59”S\", \"13°49’24”S\", \"13°32’23”S\", \"14°10’49”S\", \"10°17”20”S\", \n          \"10°7’27,6”S\", \"12°20’27”S\"),\n  lon = c(\"58°38’14”W\", \"58°45’35”W\", \"58°42’47”W\", \"56°32’46”W\", \"50°47’53”W\", \"54°58’33”W\", \"52°22’45”W\")\n)\n\n# Converter coordenadas para graus decimais\nfazendas &lt;- fazendas %&gt;%\n  mutate(lat_decimal = mapply(dms_to_decimal, str_replace_all(lat, \"[^0-9°′”’\\\"]\", \"\"), ifelse(grepl(\"S\", lat), \"S\", \"N\")),\n         lon_decimal = mapply(dms_to_decimal, str_replace_all(lon, \"[^0-9°′”’\\\"]\", \"\"), ifelse(grepl(\"W\", lon), \"W\", \"E\")))\n\n# Transformando os pontos em um objeto sf\nfazendas_sf &lt;- st_as_sf(fazendas, coords = c(\"lon_decimal\", \"lat_decimal\"), crs = 4326)\n\n# Dados do Brasil\nBRA &lt;- ne_states(country = \"Brazil\", returnclass = \"sf\")\n\n# Plotando o mapa com os pontos e a legenda\ngg &lt;- ggplot(BRA) +\n  geom_sf(fill = \"white\", color = \"black\", size = 0.3) +\n  geom_sf_interactive(data = fazendas_sf, aes(color = nome, tooltip = paste(\"Nome:\", nome, \"&lt;br&gt;Cidade:\", cidade, \"&lt;br&gt;Coordenadas:\", lat, lon)), size = 3) +\n  theme_minimal() +\n  labs(title = \"Mapa de pontos de coleta dos isolados\",\n       color = \"Tratamento/Fazenda\")\n\n# Renderizando o gráfico interativo\ngirafe(ggobj = gg)\n\n\n\n\n\n\n\nPara a leitura e importação de dados em Excel, utilizaremos o pacote readxl, para isso é necessário que instale e carregue este pacote. O pacote readxl, permite a leitura de arquivos Excel (.xlsx) sendo especialmente útil para importar dados que são frequentemente armazenados em planilhas.\n\nlibrary(readxl)\ndados &lt;- read_excel(\"SensibilidadeCory2020.xlsx\")\nhead(dados)\n\n# A tibble: 6 × 7\n  trat   aval isolado  dias   rep  dose  diam\n  &lt;chr&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Fox₢      1       1     2     1     0  23.5\n2 Fox₢      1       1     2     2     0  21.4\n3 Fox₢      1       1     2     3     0  20.0\n4 Fox₢      1       2     2     1     0  25.6\n5 Fox₢      1       2     2     2     0  26.4\n6 Fox₢      1       2     2     3     0  26.3\n\n\n\n\n\n\nlibrary(ggsci)\n\n# Médias\nmedias &lt;- dados |&gt; \n  group_by(trat,dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam)) |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = dose, y = media_diam, color = factor(isolado), group = isolado)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~aval)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Concentração\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Isolados\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\n\n# Médias\nmedias &lt;- dados |&gt; \n  group_by(trat, dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam)) |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = dose, y = media_diam, color = factor(aval), group = aval)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~isolado)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Concentração\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Avaliação\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\n\nmedias &lt;- dados |&gt; \n  group_by(trat, dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam)) |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = aval, y = media_diam, color = factor(dose), group = dose)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~isolado)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Avaliações\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Dose\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\nMODELOS DE REGRESSÃO - USANDO DIAM\n\nlibrary(dplyr)\nlibrary(drc)\nlibrary(ggplot2)\n\n# Função para ajustar múltiplos modelos de dose-resposta e selecionar o melhor modelo\najustar_e_selecionar_melhor_modelo &lt;- function(dados, tratamento, isolado, avaliacao) {\n  data_filtrado &lt;- dados %&gt;%\n    filter(trat == tratamento, isolado == isolado, aval == avaliacao) %&gt;%\n    group_by(dose) %&gt;%\n    slice_head(n = 3) %&gt;%\n    ungroup()\n  \n  # Ajustar os modelos\n  modelo1 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = LN.3()), error = function(e) NULL)\n  modelo2 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = LL.3()), error = function(e) NULL)\n  modelo3 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = W1.3()), error = function(e) NULL)\n  modelo4 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = W2.3()), error = function(e) NULL)\n  \n  # Selecionar o melhor modelo com base no AIC\n  modelos &lt;- list(LN.3 = modelo1, LL.3 = modelo2, W1.3 = modelo3, W2.3 = modelo4)\n  modelos_validos &lt;- modelos[!sapply(modelos, is.null)]\n  \n  if (length(modelos_validos) &gt; 0) {\n    aic_values &lt;- sapply(modelos_validos, AIC, simplify = TRUE)\n    melhor_modelo &lt;- names(aic_values)[which.min(aic_values)]\n    return(list(modelo = modelos_validos[[melhor_modelo]], tipo = melhor_modelo, AIC = aic_values[melhor_modelo]))\n  } else {\n    return(NULL)\n  }\n}\n\n# Lista para armazenar os melhores modelos\nmelhores_modelos &lt;- list()\n\n# Lista de tratamentos, isolados e avaliações únicos\ntratamentos &lt;- unique(dados$trat)\nisolados &lt;- unique(dados$isolado)\navaliacoes &lt;- unique(dados$aval)\n\n# Iterar sobre todas as combinações de tratamento, isolado e avaliação\nfor (tratamento in tratamentos) {\n  for (isolado in isolados) {\n    for (avaliacao in avaliacoes) {\n      # Ajustar e selecionar o melhor modelo para a combinação atual\n      melhor_modelo &lt;- ajustar_e_selecionar_melhor_modelo(dados, tratamento, isolado, avaliacao)\n      chave &lt;- paste(tratamento, isolado, avaliacao, sep = \"-\")\n      melhores_modelos[[chave]] &lt;- melhor_modelo\n    }\n  }\n}\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\n# Função para plotar os dados e o melhor modelo\nplotar_melhor_modelo &lt;- function(dados, melhor_modelo, tratamento, isolado, avaliacao) {\n  data_filtrado &lt;- dados %&gt;%\n    filter(trat == tratamento, isolado == isolado, aval == avaliacao) %&gt;%\n    group_by(dose) %&gt;%\n    slice_head(n = 3) %&gt;%\n    ungroup()\n  \n  if (!is.null(melhor_modelo$modelo)) {\n    ggplot(data_filtrado, aes(x = dose, y = diam)) +\n      geom_point() +\n      geom_line(aes(y = predict(melhor_modelo$modelo)), color = 'blue') +\n      labs(title = paste(\"Tratamento:\", tratamento, \"Isolado:\", isolado, \"Avaliação:\", avaliacao),\n           subtitle = paste(\"Melhor modelo:\", melhor_modelo$tipo, \"AIC:\", round(melhor_modelo$AIC, 2)),\n           x = \"Dose\",\n           y = \"Diâmetro\") +\n      theme_minimal()\n  } else {\n    ggplot(data_filtrado, aes(x = dose, y = diam)) +\n      geom_point() +\n      labs(title = paste(\"Tratamento:\", tratamento, \"Isolado:\", isolado, \"Avaliação:\", avaliacao),\n           subtitle = \"Nenhum modelo ajustado\",\n           x = \"Dose\",\n           y = \"Diâmetro\") +\n      theme_minimal()\n  }\n}\n\n# Plotar os gráficos para cada combinação\nfor (chave in names(melhores_modelos)) {\n  comb &lt;- unlist(strsplit(chave, \"-\"))\n  tratamento &lt;- comb[1]\n  isolado &lt;- as.numeric(comb[2])\n  avaliacao &lt;- as.numeric(comb[3])\n  melhor_modelo &lt;- melhores_modelos[[chave]]\n  \n  print(plotar_melhor_modelo(dados, melhor_modelo, tratamento, isolado, avaliacao))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ec50estimator)\ndf_ec50_LN &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::LN.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor inicial em vmmin não é finito\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\n\ndf_ec50_LL &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::LL.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor não finito fornecido por optim\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\n\ndf_ec50_W1 &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::W1.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor inicial em vmmin não é finito\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\ndf_ec50_W2 &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::W2.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor não finito fornecido por optim\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\nhead(df_ec50_LL)\n\n  ID trat aval    Estimate Std..Error      Lower     Upper\n1  1 Fox₢    1  93.4421515  28.332137  34.522247 152.36206\n2  2 Fox₢    1   0.4936527   4.651691  -9.180068  10.16737\n3  3 Fox₢    1  72.3221270  10.466677  50.555481  94.08877\n4  4 Fox₢    1 160.2615254  37.834200  81.580999 238.94205\n5  5 Fox₢    1   2.8077983  27.435216 -54.246856  59.86245\n6  6 Fox₢    1  11.5289497   7.078668  -3.191946  26.24985\n\n\n\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Função para criar o gráfico de EC50\nplot_ec50 &lt;- function(df_ec50, model_name) {\n  # Filtrar valores não positivos e maiores que 100\n  df_ec50 &lt;- df_ec50 %&gt;% filter(Estimate &gt; 0 & Estimate &lt; 100)\n  \n  # Visualização dos EC50s\n  p &lt;- as.data.frame(df_ec50) %&gt;% \n    mutate(ID = as.numeric(ID)) %&gt;% \n    ggplot(aes(ID, Estimate, color = trat)) +\n    geom_point(size = 2) +\n    geom_errorbar(aes(ymin = Lower, ymax = Upper, color = trat), width = 0) +\n    facet_wrap(~aval, scales = \"free_x\", ncol = 2) +\n    scale_y_log10() +\n    scale_x_continuous(breaks = 1:9) +\n    scale_color_manual(values = c(\"darkred\", \"steelblue\", \"darkgreen\")) +\n    labs(x = \"Isolados\", y = \"EC50\", title = paste(\"Modelo:\", model_name)) +\n    theme_minimal() +\n    coord_flip() +\n    theme(axis.text.y = element_text(angle = 90, vjust = 0.5, hjust = 1), legend.position = \"bottom\")\n  \n  return(p)\n}\n\n# Criar gráficos para cada modelo\nplot_LN &lt;- plot_ec50(df_ec50_LN, \"LN.3\")\nplot_LL &lt;- plot_ec50(df_ec50_LL, \"LL.3\")\nplot_W1 &lt;- plot_ec50(df_ec50_W1, \"W1.3\")\nplot_W2 &lt;- plot_ec50(df_ec50_W2, \"W2.3\")\n\n# Exibir os gráficos\nprint(plot_LN)\n\n\n\nprint(plot_LL)\n\n\n\nprint(plot_W1)\n\n\n\nprint(plot_W2)"
  },
  {
    "objectID": "projeto_final (1).html#carregando-o-dataset",
    "href": "projeto_final (1).html#carregando-o-dataset",
    "title": "Projeto Final da Disciplina de Análise e Visualização de Dados em Fitopatologia - FIP606",
    "section": "",
    "text": "Para a leitura e importação de dados em Excel, utilizaremos o pacote readxl, para isso é necessário que instale e carregue este pacote. O pacote readxl, permite a leitura de arquivos Excel (.xlsx) sendo especialmente útil para importar dados que são frequentemente armazenados em planilhas.\n\nlibrary(readxl)\ndados &lt;- read_excel(\"SensibilidadeCory2020.xlsx\")\nhead(dados)\n\n# A tibble: 6 × 7\n  trat   aval isolado  dias   rep  dose  diam\n  &lt;chr&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Fox₢      1       1     2     1     0  23.5\n2 Fox₢      1       1     2     2     0  21.4\n3 Fox₢      1       1     2     3     0  20.0\n4 Fox₢      1       2     2     1     0  25.6\n5 Fox₢      1       2     2     2     0  26.4\n6 Fox₢      1       2     2     3     0  26.3"
  },
  {
    "objectID": "projeto_final (1).html#visualização-de-dados",
    "href": "projeto_final (1).html#visualização-de-dados",
    "title": "Projeto Final da Disciplina de Análise e Visualização de Dados em Fitopatologia - FIP606",
    "section": "",
    "text": "library(ggsci)\n\n# Médias\nmedias &lt;- dados |&gt; \n  group_by(trat,dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam)) |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = dose, y = media_diam, color = factor(isolado), group = isolado)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~aval)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Concentração\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Isolados\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\n\n# Médias\nmedias &lt;- dados |&gt; \n  group_by(trat, dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam)) |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = dose, y = media_diam, color = factor(aval), group = aval)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~isolado)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Concentração\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Avaliação\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\n\nmedias &lt;- dados |&gt; \n  group_by(trat, dose, aval, isolado) |&gt; \n  summarize(media_diam = mean(diam)) |&gt; \n  ungroup()\n\n\n# Função de gráficos para cada tratamento\nplot_graf &lt;- function(data, tratam) {\n  ggplot(data, aes(x = aval, y = media_diam, color = factor(dose), group = dose)) +\n    geom_point()+\n    geom_line()+\n    facet_wrap(~isolado)+\n    labs(title = paste(\"Tratamento:\", tratam),\n         x = \"Avaliações\",\n         y = \"Diâmetro Micelial Médio (mm)\",\n         color = \"Dose\")+\n    scale_color_jco()+\n    theme_minimal()+\n    theme(legend.position = \"bottom\" )\n}\n\n# Função para filtrar e plotar os gráficos para cada tratamento\nfor (tratam in unique(medias$trat)) {\n  data &lt;- medias |&gt;\n    filter(trat == tratam)\n  print(plot_graf(data, tratam))\n  dev.flush()\n}\n\n\n\n\n\n\n\n\n\n\nMODELOS DE REGRESSÃO - USANDO DIAM\n\nlibrary(dplyr)\nlibrary(drc)\nlibrary(ggplot2)\n\n# Função para ajustar múltiplos modelos de dose-resposta e selecionar o melhor modelo\najustar_e_selecionar_melhor_modelo &lt;- function(dados, tratamento, isolado, avaliacao) {\n  data_filtrado &lt;- dados %&gt;%\n    filter(trat == tratamento, isolado == isolado, aval == avaliacao) %&gt;%\n    group_by(dose) %&gt;%\n    slice_head(n = 3) %&gt;%\n    ungroup()\n  \n  # Ajustar os modelos\n  modelo1 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = LN.3()), error = function(e) NULL)\n  modelo2 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = LL.3()), error = function(e) NULL)\n  modelo3 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = W1.3()), error = function(e) NULL)\n  modelo4 &lt;- tryCatch(drm(diam ~ dose, data = data_filtrado, fct = W2.3()), error = function(e) NULL)\n  \n  # Selecionar o melhor modelo com base no AIC\n  modelos &lt;- list(LN.3 = modelo1, LL.3 = modelo2, W1.3 = modelo3, W2.3 = modelo4)\n  modelos_validos &lt;- modelos[!sapply(modelos, is.null)]\n  \n  if (length(modelos_validos) &gt; 0) {\n    aic_values &lt;- sapply(modelos_validos, AIC, simplify = TRUE)\n    melhor_modelo &lt;- names(aic_values)[which.min(aic_values)]\n    return(list(modelo = modelos_validos[[melhor_modelo]], tipo = melhor_modelo, AIC = aic_values[melhor_modelo]))\n  } else {\n    return(NULL)\n  }\n}\n\n# Lista para armazenar os melhores modelos\nmelhores_modelos &lt;- list()\n\n# Lista de tratamentos, isolados e avaliações únicos\ntratamentos &lt;- unique(dados$trat)\nisolados &lt;- unique(dados$isolado)\navaliacoes &lt;- unique(dados$aval)\n\n# Iterar sobre todas as combinações de tratamento, isolado e avaliação\nfor (tratamento in tratamentos) {\n  for (isolado in isolados) {\n    for (avaliacao in avaliacoes) {\n      # Ajustar e selecionar o melhor modelo para a combinação atual\n      melhor_modelo &lt;- ajustar_e_selecionar_melhor_modelo(dados, tratamento, isolado, avaliacao)\n      chave &lt;- paste(tratamento, isolado, avaliacao, sep = \"-\")\n      melhores_modelos[[chave]] &lt;- melhor_modelo\n    }\n  }\n}\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\n# Função para plotar os dados e o melhor modelo\nplotar_melhor_modelo &lt;- function(dados, melhor_modelo, tratamento, isolado, avaliacao) {\n  data_filtrado &lt;- dados %&gt;%\n    filter(trat == tratamento, isolado == isolado, aval == avaliacao) %&gt;%\n    group_by(dose) %&gt;%\n    slice_head(n = 3) %&gt;%\n    ungroup()\n  \n  if (!is.null(melhor_modelo$modelo)) {\n    ggplot(data_filtrado, aes(x = dose, y = diam)) +\n      geom_point() +\n      geom_line(aes(y = predict(melhor_modelo$modelo)), color = 'blue') +\n      labs(title = paste(\"Tratamento:\", tratamento, \"Isolado:\", isolado, \"Avaliação:\", avaliacao),\n           subtitle = paste(\"Melhor modelo:\", melhor_modelo$tipo, \"AIC:\", round(melhor_modelo$AIC, 2)),\n           x = \"Dose\",\n           y = \"Diâmetro\") +\n      theme_minimal()\n  } else {\n    ggplot(data_filtrado, aes(x = dose, y = diam)) +\n      geom_point() +\n      labs(title = paste(\"Tratamento:\", tratamento, \"Isolado:\", isolado, \"Avaliação:\", avaliacao),\n           subtitle = \"Nenhum modelo ajustado\",\n           x = \"Dose\",\n           y = \"Diâmetro\") +\n      theme_minimal()\n  }\n}\n\n# Plotar os gráficos para cada combinação\nfor (chave in names(melhores_modelos)) {\n  comb &lt;- unlist(strsplit(chave, \"-\"))\n  tratamento &lt;- comb[1]\n  isolado &lt;- as.numeric(comb[2])\n  avaliacao &lt;- as.numeric(comb[3])\n  melhor_modelo &lt;- melhores_modelos[[chave]]\n  \n  print(plotar_melhor_modelo(dados, melhor_modelo, tratamento, isolado, avaliacao))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ec50estimator)\ndf_ec50_LN &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::LN.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor inicial em vmmin não é finito\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\n\ndf_ec50_LL &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::LL.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor não finito fornecido por optim\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\n\ndf_ec50_W1 &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::W1.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor inicial em vmmin não é finito\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\ndf_ec50_W2 &lt;- estimate_EC50(diam ~ dose,\n                         data = dados,\n                         isolate_col = \"isolado\",\n                         strata_col = c(\"trat\", \"aval\"),\n                         interval = \"delta\",\n                         fct = drc::W2.3())\n\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  valor não finito fornecido por optim\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [1]\nError in optim(startVec, opfct, hessian = TRUE, method = optMethod, control = list(maxit = maxIt,  : \n  non-finite finite-difference value [3]\n\nhead(df_ec50_LL)\n\n  ID trat aval    Estimate Std..Error      Lower     Upper\n1  1 Fox₢    1  93.4421515  28.332137  34.522247 152.36206\n2  2 Fox₢    1   0.4936527   4.651691  -9.180068  10.16737\n3  3 Fox₢    1  72.3221270  10.466677  50.555481  94.08877\n4  4 Fox₢    1 160.2615254  37.834200  81.580999 238.94205\n5  5 Fox₢    1   2.8077983  27.435216 -54.246856  59.86245\n6  6 Fox₢    1  11.5289497   7.078668  -3.191946  26.24985\n\n\n\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Função para criar o gráfico de EC50\nplot_ec50 &lt;- function(df_ec50, model_name) {\n  # Filtrar valores não positivos e maiores que 100\n  df_ec50 &lt;- df_ec50 %&gt;% filter(Estimate &gt; 0 & Estimate &lt; 100)\n  \n  # Visualização dos EC50s\n  p &lt;- as.data.frame(df_ec50) %&gt;% \n    mutate(ID = as.numeric(ID)) %&gt;% \n    ggplot(aes(ID, Estimate, color = trat)) +\n    geom_point(size = 2) +\n    geom_errorbar(aes(ymin = Lower, ymax = Upper, color = trat), width = 0) +\n    facet_wrap(~aval, scales = \"free_x\", ncol = 2) +\n    scale_y_log10() +\n    scale_x_continuous(breaks = 1:9) +\n    scale_color_manual(values = c(\"darkred\", \"steelblue\", \"darkgreen\")) +\n    labs(x = \"Isolados\", y = \"EC50\", title = paste(\"Modelo:\", model_name)) +\n    theme_minimal() +\n    coord_flip() +\n    theme(axis.text.y = element_text(angle = 90, vjust = 0.5, hjust = 1), legend.position = \"bottom\")\n  \n  return(p)\n}\n\n# Criar gráficos para cada modelo\nplot_LN &lt;- plot_ec50(df_ec50_LN, \"LN.3\")\nplot_LL &lt;- plot_ec50(df_ec50_LL, \"LL.3\")\nplot_W1 &lt;- plot_ec50(df_ec50_W1, \"W1.3\")\nplot_W2 &lt;- plot_ec50(df_ec50_W2, \"W2.3\")\n\n# Exibir os gráficos\nprint(plot_LN)\n\n\n\nprint(plot_LL)\n\n\n\nprint(plot_W1)\n\n\n\nprint(plot_W2)"
  }
]